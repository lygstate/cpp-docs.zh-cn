---
title: 格式规范语法： `printf` 和 `wprintf` 函数
description: 描述 Microsoft C 运行时 `printf` 和函数的格式说明符语法 `wprintf`
ms.date: 10/26/2020
helpviewer_keywords:
- format specification fields for printf function
- printf function format specification fields
- flag directives, printf function
- type fields, printf function
- width fields, printf function
- precision fields, printf function
ms.assetid: 664b1717-2760-4c61-bd9c-22eee618d825
ms.openlocfilehash: 6bc45f806870fce3f20fdf00d3fe7b9afd99696f
ms.sourcegitcommit: d531c567c268b676b44abbc8416ba7e20d22044b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/16/2021
ms.locfileid: "107539554"
---
# <a name="format-specification-syntax-printf-and-wprintf-functions"></a>格式规范语法： `printf` 和 `wprintf` 函数

各种 `printf` 和 `wprintf` 函数采用格式字符串和可选参数，并生成用于输出的格式化字符序列。 格式字符串包含零个或多个指令，这些指令是用于输出的文本字符或描述如何在输出中设置参数格式的已编码的转换规范。 本文介绍用于对格式字符串中的转换规范进行编码的语法。 有关这些函数的列表，请参阅[流 I/O](../c-runtime-library/stream-i-o.md)。

一个转换规范由以下形式的可选和必需字段组成：

**%**[[*flags*](#flags)][[*width*](#width)][.[*精度*](#precision)][[*size*](#size)][*类型*](#type)

转换规范的每个字段都是一个用于指示特定的格式选项或转换说明符的字符或数字。 必填的类型字段指定要应用于参数的转换类型。 可选的标志、宽度和精度字段控制格式的其他方面（如前导空格或前导零、对齐方式和显示的精度）。 大小字段指定使用和转换的参数的大小。

一个基本的转换规范仅包含百分号和一个类型字符。 例如，`%s` 指定一个字符串转换。 若要打印百分号字符，请使用 `%%`。 如果百分号后跟一个没有任何意义的字符作为格式字段，则将调用无效的参数处理程序。 有关详细信息，请参阅[参数验证](../c-runtime-library/parameter-validation.md)。

> [!IMPORTANT]
> 为了实现安全性和稳定性，请确保转换规范字符串不是用户定义的。 例如，考虑这样一个程序，它提示用户输入名称并将输入存储在一个名为 `user_name` 的字符串变量中。 若要打印 `user_name`，请勿执行下列操作：
>
> `printf( user_name ); /* Danger!  If user_name contains "%s", program will crash */`
>
> 而应执行以下操作：
>
> `printf( "%s", user_name );`

<a name="type"></a>

> [!NOTE]
> 在 Visual Studio 2015 中， `printf` 和 `scanf` 系列函数被声明为并 **`inline`** 移至 `<stdio.h>` 和 `<conio.h>` 标头。 如果迁移的是较旧的代码，则与这些函数的连接可能会出现 *LNK2019* 。 有关详细信息，请参阅 [Visual C++ change history 2003-2015](../porting/visual-cpp-change-history-2003-2015.md#stdio_and_conio)。

## <a name="type-conversion-specifier"></a>类型转换说明符

类型转换说明符字符指定是否要将相应的参数解释为字符、字符串、指针、整数或浮点数。 类型字符是唯一必填的转换规范字段，它出现在任何可选字段之后。

将根据相应的类型字符和可选的[大小](#size)前缀对紧跟格式字符串的参数进行解释。 使用或指定字符类型和的转换 `char` `wchar_t` **`c`** **`C`** ，并使用或指定单字节和多字节或宽字符字符串， **`s`** **`S`** 具体取决于正在使用的格式设置函数。 使用和指定的字符和字符串参数 **`c`** 将被 **`s`** `char` `char*` 系列函数解释为和，或被系列 `printf` `wchar_t` `wchar_t*` `wprintf` 函数解释为和。 使用和指定的字符和字符串参数 **`C`** 将被 **`S`** `wchar_t` `wchar_t*` 系列函数解释为和，或被系列 `printf` `char` `char*` `wprintf` 函数解释为和。 此行为是 Microsoft 特定的。

`short`通过使用、、、、和来指定整数类型（如、、、 `int` `long` `long long` 和其 `unsigned` 变体） **`d`** **`i`** **`o`** **`u`** **`x`** **`X`** 。 使用、、、、、、和指定浮点类型（如、 `float` `double` 和 **`long double`** ） **`a`** **`A`** **`e`** **`E`** **`f`** **`F`** **`g`** **`G`** 。 默认情况下，除非使用 *大小* 前缀进行修改，否则整数参数将被强制为 `int` 类型，浮点参数将被强制为 `double` 。 在64位系统上， `int` 是一个32位的值; 因此，如果使用 *大小* 前缀 **ll** 或 **I64** ，则在将其格式化为输出时，将截断64位整数。 使用指定的指针类型 **`p`** 使用平台的默认指针大小。

> [!NOTE]
> **特定于 Microsoft 的：**\
> **`Z`** **`c`** **`C`** **`s`** 与和函数一起使用时，类型字符和、、和 **`S`** 类型字符的行为 `printf` `wprintf` 是 Microsoft 扩展。 ISO C 标准 **`c`** **`s`** **`C`** 在所有格式设置函数中，对于窄字符和字符串以及 **`S`** 宽字符和字符串使用和一致。

### <a name="type-field-characters"></a>类型字段字符

|类型字符|参数|输出格式|
|--------------------|--------------|-------------------|
|**`c`**|字符|与 `printf` 函数一起使用时，指定单字节字符；与 `wprintf` 函数一起使用时，指定宽字符。|
|**`C`**|字符|与 `printf` 函数一起使用时，指定宽字符；与 `wprintf` 函数一起使用时，指定单字节字符。|
|**`d`**|Integer|带符号十进制整数。|
|**`i`**|Integer|带符号十进制整数。|
|**`o`**|Integer|无符号八进制整数。|
|**`u`**|Integer|无符号十进制整数。|
|**`x`**|Integer|无符号十六进制整数;使用 " `abcdef` "。|
|**`X`**|Integer|无符号十六进制整数;使用 " `ABCDEF` "。|
|**`e`**|浮点|具有格式 [-] *`d.dddd`* __e ±__] 的带符号值 *`dd`* \[ *`d`* （其中 *`d`* 是一个十进制数） *`dddd`* 是一个或多个十进制数，具体取决于指定的精度（默认值为6个），并且 *`dd`* \[ *`d`* ] 是两个或三个十进制数字，具体取决于 [输出格式](../c-runtime-library/set-output-format.md)和指数大小。|
|**`E`**|浮点|与格式相同， **`e`** 只不过 **`E`** 不会 **`e`** 引入指数。|
|**`f`**|浮点|带有格式 [-] *`dddd`* __.__ *`dddd`* ，其中 *`dddd`* 是一个或多个十进制数字的带符号值。 小数点前的数字位数取决于数字的度量值，小数点后的数字位数取决于请求的精度，或为默认的六位数。|
|**`F`**|浮点|与格式相同， **`f`** 只不过无穷大和 nan 输出都是大写。|
|**`g`**|浮点|带符号值以 **`f`** 或 **`e`** 格式显示，以更紧凑的形式显示给定的值和精度。 **`e`** 仅当值的指数小于-4 或大于或等于 *精度* 参数时，才使用格式。 截去尾随零，仅当后跟一个或多个数字时，才会显示小数点。|
|**`G`**|浮点|与格式相同 **`g`** ，不同之处在于，在 **`E`** 适当的) 中 **`e`** 引入指数 (。|
|**`a`**|浮点|带符号的十六进制双精度浮点值，其形式为 *[-] 0xh hhhh*__p ±__ *`dd`* ，其中 *hhhh* 是十六进制数字， (使用尾数的小写字母) ，并且 *`dd`* 为指数的一个或多个数字。 精度指定此点后的数字位数。|
|**`A`**|浮点|带符号的十六进制双精度浮点值，其形式为 *[-] 0Xh hhhh*__P ±__ *`dd`* ，其中 *hhhh* 是十六进制数字， (使用尾数的大写字母) ， *dd* 是指数的一个或多个数字。 精度指定此点后的数字位数。|
|**`n`**|指向整数的指针|目前成功写入流或缓冲区的字符数。 此值存储在地址作为自变量的整数中。 可通过参数大小规范前缀控制指向的整数的大小。 **`n`** 默认情况下，说明符处于禁用状态; 有关信息，请参阅重要的安全说明。|
|**`p`**|指针类型|将自变量显示为十六进制数字形式的地址。|
|**`s`**|字符串|与 `printf` 函数一起使用时，指定单字节或多字节字符串；与 `wprintf` 函数一起使用时，指定宽字符字符串。 将于第一个空字符之前或达到精度值时显示字符。|
|**`S`**|字符串|与 `printf` 函数一起使用时，指定宽字符字符串；与 `wprintf` 函数一起使用时，指定单字节或多字节字符串。 将于第一个空字符之前或达到精度值时显示字符。|
|**`Z`**|`ANSI_STRING` 或 `UNICODE_STRING` 结构|当或结构的地址 [`ANSI_STRING`](/windows/win32/api/ntdef/ns-ntdef-string) [`UNICODE_STRING`](/windows/win32/api/ntdef/ns-ntdef-_unicode_string) 作为参数传递时，将显示由结构的字段指向的缓冲区中包含的字符串 `Buffer` 。 使用 *大小* 修饰符前缀 **`w`** 指定 `UNICODE_STRING` 参数，例如 `%wZ` 。 结构的 `Length` 字段必须设置为字符串的长度（以字节为单位）。 结构的 `MaximumLength` 字段必须设置为缓冲区的长度（以字节为单位）。<br /><br />通常， **`Z`** 只能在使用转换规范的驱动程序调试函数（如和）中使用类型字符 `dbgPrint` `kdPrint` 。|

从 Visual Studio 2015 开始，如果与浮点转换说明符相对应的参数 (、、、、、、、 **`a`** **`A`** **`e`** **`E`** **`f`** **`F`** **`g`** **`G`**) 是无限、不定或 NaN，则格式化的输出应符合 C99 标准。 下表列出了格式化的输出：

|值|输出|
|-----------|------------|
|infinity|`inf`|
|静默 NaN|`nan`|
|信令 NaN|`nan(snan)`|
|不定 NaN|`nan(ind)`|

可能以符号作为其中任何一个值的前缀。 如果浮点类型转换说明符字符是一个大写字母，则输出也将使用大写字母格式。 例如，如果格式说明符是 `%F`而不是 `%f`，则 infinity 的格式将被设置为 `INF`，而不是 `inf`。 `scanf` 函数也可以分析这些字符串，使这些值可以通过 `printf` 和 `scanf` 函数进行往返。

在 Visual Studio 2015 之前，CRT 使用一种不同的非标准格式作为无穷大、不定和 NaN 值的输出：

|值|输出|
|-----------|------------|
|+ 无穷| 随机数字`1.#INF` |
|- 无穷| 随机数字`-1.#INF` |
|不定（与静默 NaN 相同）|*数字 随机数字* `.#IND` |
|NaN|*数字 随机数字* `.#NAN` |

其中的任何一种都可能已采用符号作为前缀，并且可能已根据字段宽度和精度进行了不同的格式化，有时会出现异常的影响。 例如， `printf("%.2f\n", INFINITY)` 打印 `1.#J` 是因为 *#INF* 会 "舍入为两位数"。

> [!NOTE]
> 如果与 `%s` 或 `%S` 对应的参数，或与 `%Z` 对应的参数的 `Buffer` 字段为空指针，则将显示“(null)”。

> [!NOTE]
> 在所有的指数格式中，要显示的指数的位数最少为两位，仅在必要时使用三位。 通过使用 [`_set_output_format`](../c-runtime-library/set-output-format.md) 函数，你可以将显示的数字位数设置为三个，以便向后兼容性与为 Visual Studio 2013 和之前的代码编写的代码。

> [!IMPORTANT]
> 因为 `%n` 格式在本质上是不安全的，所以在默认情况下是禁用的。 如果在格式字符串中遇到 `%n`，则将调用无效的参数处理程序，如[参数验证](../c-runtime-library/parameter-validation.md)中所述。 若要启用 `%n` 支持，请参阅 [`_set_printf_count_output`](../c-runtime-library/reference/set-printf-count-output.md) 。

<a name="flags"></a>

## <a name="flag-directives"></a>标志指令

转换规范中的第一个可选字段包含标志指令、零个或多个标志字符，用于指定输出对齐方式以及控制符号、空白、前导零、小数点以及八进制和十六进制前缀的输出。 转换规范中可能会出现多个标志指令，并且标志字符可能会按任意顺序出现。

### <a name="flag-characters"></a>标志字符

|标志|含义|默认|
|----------|-------------|-------------|
|**`-`**|在给定的字段宽度内左对齐结果。|右对齐。|
|**`+`**|如果输出值为有符号类型，请使用符号 (+ 或-) 为其加上前缀。|只对有符号的负值 (-) 显示符号。|
|**`0`**|如果 *width* 的前缀为 **`0`** ，则将添加前导零，直到达到最小宽度。 如果 **`0`** 和都 **`-`** 出现， **`0`** 则忽略。 如果 **`0`** 为整数格式指定了， (、、、、 **`i`** **`u`** **`x`** **`X`** **`o`** 、 **`d`**) 和精度规范（例如）， `%04.d` **`0`** 则将忽略。 如果 **`0`** 为 **`a`** 或浮点格式指定了，则在 **`A`** 或前缀之后为尾数预置前导零 `0x` `0X` 。|不填充。|
|**空白 ( "" )**|如果输出值已签名且为正值，则使用空值作为其前缀。 如果空白和 + 标志同时出现，空白则将被忽略。|没有显示空白。|
|**`#`**|当它与 **`o`** 、或格式一起使用时 **`x`** **`X`** ，标志将 **`#`** 分别使用 `0` 、 `0x` 或 `0X` ，以作为任何非零输出值的前缀。|没有显示空白。|
||当它与 **`e`** 、 **`E`** 、、、或格式一起使用时 **`f`** **`F`** **`a`** **`A`** ，标志将 **`#`** 强制输出值包含小数点。|仅当小数点后紧跟数字时，才会显示小数点。|
||当它与或格式一起使用时 **`g`** **`G`** ， **`#`** 标志将强制输出值包含小数点，并防止截断尾随零。<br /><br /> 与 **`c`** 、、 **`d`** **`i`** 、 **`u`** 或一起使用时，将被忽略 **`s`** 。|仅当小数点后紧跟数字时，才会显示小数点。 尾随零将被截断。|

<a name="width"></a>

## <a name="width-specification"></a>宽度规范

在转换规范中，可选宽度规范字段出现在任何标志字符之后。 *`width`* 参数是一个非负的十进制整数，该整数控制要输出的最小字符数。 如果输出值中的字符数小于指定宽度，则将在值的左侧或右侧添加空格，具体取决于是否指定左对齐标志 (**`-`**) ，直到达到最小宽度。 如果 *`width`* 以0作为前缀，则将前导零添加到整数或浮点转换直到达到最小宽度，只不过转换为无穷或 `NaN` 。

宽度规范永远不会导致值被截断。 如果输出值中的字符数大于指定宽度，或如果 *`width`* 未提供，则值的所有字符都将输出，根据精度规范。

如果宽度规范是一个星号 (`*`)，则参数列表中的 `int` 参数将提供此值。 *`width`* 参数必须在参数列表中要设置格式的值之前，如以下示例中所示：

`printf("%0*d", 5, 3);  /* 00003 is output */`

转换规范中缺少或较小的 *`width`* 值不会导致输出值的截断。 如果转换的结果大于 *`width`* 值，则字段将扩展以包含转换结果。

<a name="precision"></a>

## <a name="precision-specification"></a>精度规范

在转换规范中，第三个可选字段是精度规范。 它包含一个句点 (`.`) 后跟一个非负十进制整数，具体取决于转换类型、指定字符串字符的数量、小数位数或要输出的有效位数。

与宽度规范不同的是，精度规范可能导致输出值截断或浮点值舍入。 如果 *`precision`* 将指定为0，并且要转换的值为0，则结果将不会输出任何字符，如以下示例中所示：

`printf( "%.0d", 0 );      /* No characters output */`

如果精度规范是一个星号 (`*`)，则参数列表中的某个 `int` 参数将提供此值。 在参数列表中， *`precision`* 参数必须位于要设置格式的值之前，如以下示例中所示：

`printf( "%.*f", 3, 3.14159265 );  /* 3.142 output */`

*`type`* *`precision`* 如果省略，字符将确定或默认精度 *`precision`* ，如下表所示。

### <a name="how-precision-values-affect-type"></a>精度值如何影响类型

|类型|含义|默认|
|----------|-------------|-------------|
|**`a`**, **`A`**|精度指定此点后的数字位数。|默认精度为 13。 如果精度为0，则不会打印小数点，除非 **`#`** 使用标志。|
|**`c`**, **`C`**|精度不产生任何影响。|打印字符。|
|**`d`**, **`i`**, **`o`**, **`u`**, **`x`**, **`X`**|精度指定要打印的最小数字位数。 如果参数中的数字位数小于精度，则将在输出值的左侧使用零进行填充。 当位数超过 *精度* 时，该值不会被截断。|默认精度为 1。|
|**`e`**, **`E`**|精度指定此小数点后要打印的数字位数。 打印的最后一位数舍入。|默认精度为 6。 如果 *精度* 为0，或者该时间段 (`.`) 出现时不包含数字，则不会打印小数点。|
|**`f`**, **`F`**|精度值指定此小数点后的数字位数。 如果出现小数点，则在它之前至少会显示一个数字。 该值舍入为适当数量的数字。|默认精度为 6。 如果 *精度* 为0，或者如果句点 (`.`) 出现时没有数字，则不会打印小数点。|
|**`g`**, **`G`**|精度指定打印的最大有效位数。|打印六个有效位数，并且任何尾随零都会被截断。|
|**`s`**, **`S`**|精度指定要打印的最大字符数。 不会打印超过精度的字符。|输出字符，直到找到空字符。|

<a name="size"></a>

## <a name="argument-size-specification"></a>参数大小规范

在转换规范中，大小字段是类型转换说明符的参数长度修饰符。 *类型* 字段的 *大小* 字段前缀- **`hh`** 、 **`h`** 、 **`j`** 、 **`l`** (小写 L) ，，，，，， **`L`** **`ll`** **`t`** **`w`** **`z`** **`I`** (大写 i) ， **`I32`** ，和 **`I64`** ）指定对应参数的 "大小" （长或短、32位或64位、单字节字符或宽字符），具体取决于它们修改的转换说明符。 这些大小前缀在 `printf` 和 `wprintf` 系列函数中与 *类型* 字符一起使用，以指定参数大小的解释（如下表中所示）。 大小字段对于某些参数类型是可选的。 未指定任何大小前缀时，格式化程序使用整数参数（例如，有符号或无符号的 `char`、`short`、`int`、`long` 和枚举类型）作为 32 位 `int` 类型，而使用 `float`、`double` 和 `long double` 浮点参数作为 64 位 `double` 类型。 此行为与变量自变量列表的默认自变量提升规则相匹配。 有关参数升级的详细信息，请参阅 [后缀表达式](../cpp/postfix-expressions.md)中的省略号和默认参数。 在32位和64位系统上，64位整数参数的转换规范必须包含或的大小前缀 **`ll`** **`I64`** 。 否则，格式化程序的行为是不明确的。

某些类型在 32 位和 64 位代码中具有不同大小。 例如，`size_t` 在针对 x86 编译的代码中是 32 位长，而在针对 x64 编译的代码中是 64 位。 若要为宽度可变的类型创建与平台无关的格式设置代码，可以使用宽度可变的参数大小修饰符。 请改用64位参数大小修饰符，并将可变宽度参数类型显式提升为64位。 特定于 Microsoft 的 **`I`** (大写 i) 参数大小修饰符处理可变宽度整数参数，但建议采用类型特定的 **`j`** 、 **`t`** 和 **`z`** 修饰符来实现可移植性。

### <a name="size-prefixes-for-printf-and-wprintf-format-type-specifiers"></a>printf 和 wprintf 格式类型说明符的大小前缀

|若要指定|使用前缀|及类型说明符|
|----------------|----------------|-------------------------|
|`char`<br />`unsigned char`|**`hh`**|**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`**|
|`short int`<br />`short unsigned int`|**`h`**|**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`**|
|`__int32`<br />`unsigned __int32`|**`I32`**|**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`**|
|`__int64`<br />`unsigned __int64`|**`I64`**|**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`**|
|`intmax_t`<br />`uintmax_t`|**`j`** 或 **`I64`**|**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`**|
|`long double`|**`l`** (小写 L) 或 **`L`**|**`a`**、 **`A`** 、 **`e`** 、 **`E`** 、 **`f`** 、 **`F`** 、 **`g`** 或 **`G`**|
|`long int`<br />`long unsigned int`|**`l`** (小写 L)  |**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`** |
|`long long int`<br />`unsigned long long int`|**`ll`**  (小写的 LL) |**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`**|
|`ptrdiff_t`|**`t`** 或 **`I`** (大写 i) |**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`**|
|`size_t`|**`z`** 或 **`I`** (大写 i) |**`d`**、 **`i`** 、 **`o`** 、 **`u`** 、 **`x`** 或 **`X`**|
|单字节字符|**`h`**|**`c`** 或 **`C`**|
|宽字符|**`l`** (小写 L) 或 **`w`**|**`c`** 或 **`C`**|
|单字节字符串|**`h`**|**`s`**、**`S`** 或 **`Z`**|
|宽字符字符串|**`l`** (小写 L) 或 **`w`**|**`s`**、**`S`** 或 **`Z`**|

`ptrdiff_t` 和 `size_t` 类型在 32 位平台上为 `__int32` 或 `unsigned __int32`，在 64 位平台上为 `__int64` 或 `unsigned __int64`。 **`I`** (大写 i) 、、 **`j`** **`t`** 和 **`z`** 大小前缀采用平台的正确参数宽度。

在 Visual C++ 中，虽然 `long double` 是互异的类型，但是它具有与 `double` 相同的内部表示形式。

**`hc`** 或 **`hC`** 类型说明符与 **`c`** 函数中的 `printf` 和函数中的 **`C`** 同义 `wprintf` 。 **`lc`**、 **`lC`** 、 **`wc`** 或类型说明符与函数中的 **`wC`** **`C`** `printf` 和函数的同义词 **`c`** `wprintf` 。 **`hs`** 或 **`hS`** 类型说明符与 **`s`** 函数中的 `printf` 和函数中的 **`S`** 同义 `wprintf` 。 **`ls`**、 **`lS`** 、 **`ws`** 或类型说明符与函数中的 **`wS`** **`S`** `printf` 和函数的同义词 **`s`** `wprintf` 。

> [!NOTE]
> **特定于 Microsoft 的：**\
> **`I`** (大写 i) ，， **`I32`** ， **`I64`** 和 **`w`** 参数大小修饰符前缀是 Microsoft 扩展，不与 ISO C 兼容。 当与类型的数据一起使用时， **`h`** 前缀为类型的数据，而与类型的数据一起使用时，则使用前缀 `char` " **`l`** (小写") 前缀 `double` 。

## <a name="see-also"></a>另请参阅

[`printf`, `_printf_l`, `wprintf`, `_wprintf_l`](../c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l.md)\
[`printf_s`, `_printf_s_l`, `wprintf_s`, `_wprintf_s_l`](../c-runtime-library/reference/printf-s-printf-s-l-wprintf-s-wprintf-s-l.md)\
[`printf_p` 位置参数](../c-runtime-library/printf-p-positional-parameters.md)
